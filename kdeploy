#!/bin/bash

# Set options:

# Fail on a single failed command in a pipeline
set -o pipefail

# Save global script args
if [ -z "$1" ]; then
    ARGS=("--help")
else
    ARGS=("$@")
fi

# Fail on error and undefined vars (please don't use global vars, but
# evaluation of functions for return values)
set -eu

# Checks if a flag is present in the arguments.
hasflag() {
  local flags="$@"
  for var in "${ARGS[@]}"; do
    for flag in $flags; do
      if [ "$var" = "$flag" ]; then
        echo 'true'
        return
      fi
    done
  done
  echo 'false'
}

# Read the value of an option.
readopt() {
  local opts="$@"
  for var in "${ARGS[@]}"; do
    for opt in $opts; do
      if [[ "$var" = ${opt}* ]]; then
        local value="${var//${opt}=/}"
        if [ "$value" != "$var" ]; then
          # Value could be extracted
          echo $value
          return
        fi
      fi
    done
  done
  # Nothing found
  echo ""
}

# Directory where this script is located
basedir() {
    # Default is current directory
    local script=${BASH_SOURCE[0]}

    # Resolve symbolic links
    if [ -L $script ]; then
        if readlink -f $script >/dev/null 2>&1; then
            script=$(readlink -f $script)
        elif readlink $script >/dev/null 2>&1; then
            script=$(readlink $script)
        elif realpath $script >/dev/null 2>&1; then
            script=$(realpath $script)
        else
            echo "ERROR: Cannot resolve symbolic link $script"
            exit 1
        fi
    fi

    local dir=$(dirname "$script")
    local full_dir=$(cd "${dir}" && pwd)
    echo ${full_dir}
}

# Main loop
run() {
    local first_arg=${1:-}
    local cmd_dir="$(basedir)/commands"
    local command
    if [ -n "${first_arg}" ] && [[ ${first_arg} != -* ]]; then
        command="$first_arg"
        if [ ! -f "$cmd_dir/$command" ]; then
            echo
            echo ">>>> Unknown command '$command'"
            echo
            display_help
            exit 1
        fi
    fi

    if [ "${command:-}" == "help" ] || $(hasflag --help -h); then
        display_help ${command:-}
        exit 0
    fi

    source "$cmd_dir/$command"

    eval "${command}::run"
}

display_help() {
  cat << EOT
Usage: kdeploy <subcommand> <opts>

Kubernetes deployment helper

Commands:
  help -- Print this help command

Options:

-h --help        Print help message
EOT
}

# ===========================================================

if $(hasflag --verbose -v); then
    export PS4='+($(basename ${BASH_SOURCE[0]}):${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -x
fi

run "$@"
